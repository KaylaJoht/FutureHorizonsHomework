use ot;
# 1. Find the total sales revenue generated by each employee.
-- NOTES: It was not clear whether or not canceled orders should be included in the total_sales_revenue. 
-- So this solution assumes all sales made by an employee-- whether it was canceled or pending -- are counted
-- I got this answer wrong
SELECT e.employee_id, CONCAT(first_name, " ", last_name) as full_name, SUM(quantity * unit_price) as total_sales_revenue
FROM employees as e LEFT JOIN orders as o
ON e.employee_id = o.salesman_id
LEFT JOIN order_items as oi
ON oi.order_id = o.order_id
GROUP BY e.employee_id;

SELECT* from order_items;


# 2. Retrieve the top 5 customers with the highest credit limits.
SELECT*
FROM customers
ORDER BY credit_limit DESC
LIMIT 5;

# 3. List the products with their categories and the total quantity available in each warehouse.
SELECT product_name, category_name , warehouse_id, quantity
FROM products as p INNER JOIN product_categories as pc
ON p.category_id = pc.category_id
INNER JOIN inventories as i
ON i.product_id = p.product_id;


# 4. Find the customers information of those who have had their orders Canceled or their order 
#	 status is Pending
Select*
FROM customers
WHERE customer_id in (
SELECT customer_id
FROM orders
WHERE status != 'Shipped');

# 5. Calculate the average standard cost and list price for each product category.
SELECT category_name, avg(standard_cost) as average_cost, avg(list_price) as average_price
FROM products INNER JOIN product_categories
ON products.category_id = product_categories.category_id
GROUP BY products.category_id;

# 6. Retrieve the top 3 best-selling products in terms of total quantity sold.
-- Did not account for canceled, but that's okay
SELECT product_name, description, SUM(quantity) as units_sold
FROM order_items INNER JOIN products
ON products.product_id = order_items.product_id
GROUP BY products.product_id
ORDER BY units_sold desc
LIMIT 3;

# 7. Find the customers who have placed orders for products from more than two different 
#	 categories.
SELECT DISTINCT customers.customer_id, customers.name, COUNT( DISTINCT product_categories.category_id) as categories
FROM customers INNER JOIN orders
ON customers.customer_id = orders.customer_id
INNER JOIN order_items
ON orders.order_id = order_items.order_id
INNER JOIN products
ON order_items.product_id = products.product_id
INNER JOIN product_categories
ON products.category_id = product_categories.category_id
GROUP BY customers.customer_id
HAVING categories > 2;

# 8. List the sales revenue generated by each product category in descending order.
-- Once again, I forgot to include quantity
-- Ammendment: add quantity
SELECT products.category_id, category_name, sum(quantity * unit_price) as sales_revenue
FROM orders INNER JOIN order_items
ON orders.order_id = order_items.order_id
INNER JOIN products
ON order_items.product_id = products.product_id
INNER JOIN product_categories
ON products.category_id = product_categories.category_id
GROUP BY products.category_id
ORDER BY sales_revenue desc;

# 9. Retrieve the employees who have not been assigned as managers to any other employee.
-- I got this WRONG :( :( :( :(
-- AMMENDMENT added subqueries
Select *
FROM employees
WHERE employee_id not in 
(SELECT DISTINCT manager_id
FROM employees
WHERE manager_id is not null);

# 10. Calculate the average credit limit for customers in each region.
#I am completely unsure of the correct way to accomplish this, so this was my method
#This method does require a bit of manual editing, which makes it quite ineffective for real-world use

#After doing some research, I discovered that these contacts correspond to these countries
SELECT substr(phone, 1,3)
FROM contacts;
-- Europe. +39, +41, +49
-- Americas, +1
-- Asia, +66, +81, +86, +91
-- Middle East and Africa

SELECT CAST(substr(phone, 1,3) as UNSIGNED)
FROM contacts;

#This view extracts every country that has a postal code of +1, indicating that it is in either North America or Canada
#Any other country in the Americas and it won't apply
Create view getAmericas As
SELECT customers.customer_id, contact_id, 2 as region_id
FROM customers INNER JOIN contacts
ON customers.customer_id = contacts.customer_id
WHERE phone Like '+1%';

#This view extracts every country that has a postal code that belongs to Europe
#Any other country in the Europe and it won't apply
Create view getEurope AS
SELECT customers.customer_id, contact_id, 1 as region_id
FROM customers INNER JOIN contacts
ON customers.customer_id = contacts.customer_id
WHERE SUBSTR(phone,1,3) in ('+39', '+41', '+49');

#This view extracts every country that has a postal code that belongs to Asia
#Any other country in the Asia and it won't apply
CREATE VIEW getAsia as
SELECT customers.customer_id, contact_id, 3 as region_id
FROM customers INNER JOIN contacts
ON customers.customer_id = contacts.customer_id
WHERE SUBSTR(phone,1,3) in ('+66', '+81', '+86', '+91');

#This view Joins all the previously created views to create a select statement that includes the region_id
create view country_regions as
Select getAmericas.customer_id, getAmericas.region_id
FROM getAmericas LEFT JOIN getEurope
ON getAmericas.customer_id = getEurope.customer_id
UNION
Select getEurope.customer_id, getEurope.region_id
FROM getAmericas RIGHT JOIN getEurope
ON getAmericas.customer_id = getEurope.customer_id
UNION
SELECT getAsia.customer_id, getAsia.region_id
FROM getEurope RIGHT JOIN getAsia
ON getEurope.customer_id = getAsia.customer_id;

#Finally, returning the regions, and the average credit_limit for the region
SELECT regions.region_id, region_name, AVG(credit_limit) as average_credit
FROM customers INNER JOIN country_regions
ON customers.customer_id = country_regions.customer_id
RIGHT JOIN regions
ON country_regions.region_id = regions.region_id
GROUP BY region_id;

